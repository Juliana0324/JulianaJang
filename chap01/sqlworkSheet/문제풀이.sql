SELECT * FROM EMPLOYEES;
--employee 테이블에서 사원번호 사원이름, 월급, 연봉을 구하고 각 칼럼명을 그렇게 출력
SELECT EMPLOYEE_ID "사원번호", FIRST_NAME||' '|| LAST_NAME "사원이름", 
SALARY "월급", SALARY*12 "연봉"
FROM EMPLOYEES;

--업무(JOB)를 중복되지 않게 출력하세요
SELECT DISTINCT JOB_ID FROM EMPLOYEES;

-- 사원번호가 145, 152, 203사원의 정보를 사원번호,성명, 담당업무, 급여, 입사일자를 출력
SELECT EMPLOYEE_ID, FIRST_NAME||' '||LAST_NAME, SALARY, HIRE_DATE
FROM EMPLOYEES WHERE EMPLOYEE_ID IN (145,152,203);

--입사일자가 05년이상인 사람모두 출력
SELECT * FROM EMPLOYEES WHERE HIRE_DATE>'05/01/01';
--직무가 CLERK 로 끝나는 사람이 아닌 사람들 중
--부서 번호가 30 또는 50번이고 입사년도가 05년도 이상인 사람의
-- 사원번호,이름, 성,급여, 입사일조회
SELECT EMPLOYEE_ID, FIRST_NAME||' '||LAST_NAME "NAME",SALARY, HIRE_DATE
FROM EMPLOYEES
WHERE JOB_ID != '%CLERK'
AND department_id IN (30,50)
AND HIRE_DATE > '05/01/01'
;
--입사일이 사원번호 157번 보다 적은 사람들의 모든 속성조회
SELECT * FROM EMPLOYEES WHERE HIRE_DATE<
(SELECT HIRE_DATE FROM EMPLOYEES WHERE EMPLOYEE_ID='157');

--직무가 사원번호 199번과 같은사람들의 모든 속성조회
SELECT * FROM EMPLOYEES WHERE JOB_ID=
(SELECT JOB_ID FROM EMPLOYEES WHERE EMPLOYEE_ID='199');

-- 입사일이 매니저가 100번인 사람들보다 모두 늦은 사람들중에 
-- 급여가 FIRST_NAME이 NANCY인 사람보다 작은사람들의 
--사원번호, 이름, 급여, 입사일 , 매니저번호 조회
SELECT EMPLOYEE_ID, FIRST_NAME||' '||LAST_NAME "NAME",SALARY,HIRE_DATE,MANAGER_ID
FROM EMPLOYEES WHERE SALARY<ALL(SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME='NANCY')
AND HIRE_DATE >ALL(SELECT HIRE_DATE FROM EMPLOYEES WHERE manager_id='100')
;

--직무가 IT-PROG인사람들보다 급여가 큰사람들 중에 
--부서는 사원번호 140번과 동일하고 매니저는 사원번호 141번과 동일한 사람의 
--사원번호, 이름, 급여, 직무, 부서, 매니저번호 조회
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, JOB_ID, DEPARTMENT_ID,MANAGER_ID
FROM EMPLOYEES 
WHERE SALARY>ALL(SELECT SALARY FROM EMPLOYEES WHERE JOB_ID='IT-PROG')
AND DEPARTMENT_ID=ALL(SELECT DEPARTMENT_ID FROM EMPLOYEES 
WHERE EMPLOYEE_ID='140' AND MANAGER_ID='141');

--부서인원이 4명보다 많은 부서의 부서번호, 인원수, 급여의 합을 구하시오
SELECT DEPARTMENT_ID, COUNT(*),SUM(SALARY) FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID
HAVING COUNT(*)<4;

--업무별 급여의 평균이 10000이상인 업무에 대해서 업무명, 평군급여 , 급여의 합을 구하시오
SELECT JOB_ID, AVG(SALARY), SUM(SALARY) FROM EMPLOYEES
GROUP BY JOB_ID
HAVING AVG(SALARY)<10000;

--직무별 최대 급여를 받는 사람의 모든 속성을 출력
SELECT * FROM EMPLOYEES WHERE(JOB_ID,SALARY) IN 
(SELECT JOB_ID,MAX(SALARY) FROM EMPLOYEES GROUP BY JOB_ID);

--부서별 월급 급여에서 월급이 가장 높은 부서의 평균과 가장 낮은 급여 출력
SELECT MAX(ROUND(AVG(SALARY))) AS HIGER_SAL , MIN(ROUND(AVG(SALARY))) AS LOWER_SAL
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID;

--MANAGER만 가려내기
SELECT EMPLOYEE_ID, FIRST_NAME AS MANAGER_NAME FROM EMPLOYEES
WHERE EMPLOYEE_ID IN 
(SELECT DISTINCT MANAGER_ID FROM EMPLOYEES);

--부서별로 평균 급여보다 많이 받는 사람출력
SELECT * FROM EMPLOYEES E
JOIN 
(SELECT DEPARTMENT_ID, AVG(SALARY) AS AVG_SALARY FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID)D
ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
WHERE E.SALARY>D.AVG_SALARY
;
SELECT * FROM LOCATIONS;
--근무지가 CHICAGO 인 모든 사원의 이름, 업무, 부서번호 및 부서이름을 조회
SELECT E.FIRST_NAME||' '||E.LAST_NAME NAME, E.JOB_ID, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E
JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
JOIN LOCATIONS L 
ON D.LOCATION_ID=L.LOCATION_ID
WHERE L.CITY='SOUTHLAKE'
;
--직무별 급여 평균보다 적게받는 사람들의 모든 속성+ 직무이름을 출력
SELECT * FROM EMPLOYEES E
JOIN (SELECT DISTINCT JOB_ID,AVG(SALARY) AVG_SAL FROM EMPLOYEES 
GROUP BY JOB_ID) JSAL
ON E.JOB_ID=JSAL.JOB_ID
JOIN JOBS J
ON E.JOB_ID = J.JOB_ID
WHERE SALARY<AVG_SAL
;
--도시가 SOUTHLAKE인 사람들의 명수 출력
SELECT COUNT(*) FROM EMPLOYEES EMP
JOIN (SELECT * FROM DEPARTMENTS) DEPT
ON EMP.DEPARTMENT_ID=DEPT.DEPARTMENT_ID 
JOIN LOCATIONS L
ON DEPT.LOCATION_ID=L.LOCATION_ID
WHERE L.CITY='SOUTHLAKE';
